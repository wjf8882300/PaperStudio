<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PaperStudio - 信笺纸设计工具</title>
    <script src="./static/tailwindcss.js"></script>
    <link href="./static/toastify.min.css" rel="stylesheet" />
    <script src="./static/fabric.min.js"></script>
    <script src="./static/jspdf.umd.min.js"></script>
    <link href="./static/icons.min.css" rel="stylesheet" />
    <script src="./static/hotkeys-js.min.js"></script>
    <script src="./static/toastify-js.js"></script>
    <link rel="preload" href="./static/SourceHanSerifCN-Bold.ttf" as="font" type="font/ttf" crossorigin />
    <style>
      /* 基础滚动条隐藏 */
      .no-scrollbar::-webkit-scrollbar {
        display: none;
      }

      .no-scrollbar {
        -ms-overflow-style: none;
        scrollbar-width: none;
      }

      /* 自定义滚动条样式 */
      .custom-scrollbar::-webkit-scrollbar {
        width: 6px;
        height: 6px;
      }

      .custom-scrollbar::-webkit-scrollbar-track {
        background: transparent;
      }

      .custom-scrollbar::-webkit-scrollbar-thumb {
        background-color: #cbd5e1;
        border-radius: 3px;
      }

      .custom-scrollbar::-webkit-scrollbar-thumb:hover {
        background-color: #94a3b8;
      }

      /* UI 交互状态 */
      .tool-btn.active {
        background-color: #fee2e2;
        color: #e11d48;
        border-color: #e11d48;
      }

      /* 画布区域背景 */
      #scrollContainer {
        background-image: radial-gradient(#ddd 1px, transparent 1px);
        background-size: 20px 20px;
        display: block;
      }

      #zoomViewport {
        margin: 40px auto;
        transform-origin: 0 0;
        overflow: hidden;
        border-radius: 2px;
        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      }

      /* 图层列表样式 */
      .layer-item {
        border-left: 3px solid transparent;
      }

      .layer-item:hover {
        background-color: #f3f4f6;
      }

      .layer-item.active {
        background-color: #eff6ff;
        border-left-color: #3b82f6;
      }

      /* 模态框与卡片 */
      .modal-backdrop {
        background-color: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(4px);
      }

      .template-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
      }

      /* 光标状态 */
      .canvas-container.grabbing-mode canvas {
        cursor: grabbing !important;
      }

      .canvas-container.grab-mode canvas {
        cursor: grab !important;
      }

      /* 紧凑型表单控件 */
      .compact-input {
        font-size: 12px;
        padding: 4px 6px;
        height: 28px;
      }

      .compact-label {
        color: #6b7280;
        margin-bottom: 2px;
        display: block;
      }

      /* 样式按钮 */
      .style-btn {
        width: 28px;
        height: 28px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .style-btn.active {
        background-color: #e5e7eb;
        font-weight: bold;
        color: #000;
      }

      /* 下拉菜单 */
      .dropdown:hover .dropdown-menu {
        display: block;
      }

      .dropdown-menu {
        display: none;
        position: absolute;
        background-color: white;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        border: 1px solid #e5e7eb;
        border-radius: 0.5rem;
        z-index: 50;
        padding: 0.5rem;
        top: 100%;
        left: 0;
        width: 120px;
      }

      @font-face {
        font-family: "SourceHanSerifCN-Bold";
        src: url("./static/SourceHanSerifCN-Bold.ttf") format("truetype");
        font-weight: normal;
        font-style: normal;
        font-display: swap;
      }

      /* ========================================= */
      /* 打印专用样式 */
      /* ========================================= */

      #printContainer {
        display: none;
      }

      @media print {
        body > *:not(#printContainer) {
          display: none !important;
        }

        #printContainer {
          display: block !important;
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          z-index: 99999;
          background: white;
        }

        #printContainer img {
          width: 100%;
          height: auto;
          display: block;
        }
      }
    </style>
  </head>
  <body class="bg-gray-50 h-screen flex flex-col text-slate-700 font-sans overflow-hidden">
    <div id="welcomeModal" class="fixed inset-0 z-50 flex items-center justify-center modal-backdrop transition-opacity duration-300">
      <div class="bg-white w-[850px] h-[550px] rounded-2xl shadow-2xl flex overflow-hidden">
        <div class="w-1/3 bg-slate-900 text-white p-8 flex flex-col justify-between relative overflow-hidden">
          <div class="relative z-10">
            <div class="flex items-center gap-3 mb-8">
              <div class="bg-red-600 text-white p-2 rounded-lg">
                <i class="ph ph-article text-3xl"></i>
              </div>
              <div>
                <h1 class="text-xl font-bold tracking-tight">PaperStudio</h1>
                <p class="text-slate-400 text-xs">简单的信稿笺纸设计工具</p>
              </div>
            </div>
            <div class="space-y-4">
              <button onclick="App.templates.load('blank_a4')" class="w-full py-3 px-4 bg-red-600 hover:bg-red-700 rounded-xl flex items-center gap-3 transition group">
                <i class="ph ph-plus-circle text-xl"></i>
                <span class="font-medium">新建空白信纸</span>
              </button>
              <button onclick="document.getElementById('projectImportInput').click()" class="w-full py-3 px-4 bg-slate-800 hover:bg-slate-700 rounded-xl flex items-center gap-3 transition">
                <i class="ph ph-folder-open text-xl text-slate-400"></i>
                <span class="font-medium">打开信纸文件</span>
              </button>
            </div>
          </div>
          <a href="https://github.com/jingguanzhang/PaperStudio" target="_blank" class="relative z-20 flex items-center gap-2 text-slate-500 hover:text-white transition-colors cursor-pointer w-fit group">
            <i class="ph ph-github-logo text-2xl group-hover:scale-110 transition-transform"></i>
            <span class="text-xs font-medium">Github 源码</span>
          </a>
          <i class="ph ph-scroll absolute -bottom-5 -right-10 text-[200px] text-slate-800 opacity-50 rotate-12"></i>
        </div>
        <div class="w-2/3 p-8 bg-gray-50 flex flex-col">
          <h2 class="text-lg font-bold text-slate-800 mb-4 flex justify-between items-center">从模板开始</h2>
          <div id="templateGrid" class="grid grid-cols-2 gap-4 overflow-y-auto pr-2 custom-scrollbar"></div>
        </div>
      </div>
    </div>

    <input type="file" id="projectImportInput" hidden accept=".paper" />
    <input type="file" id="imgUpload" hidden accept="image/*" />
    <input type="file" id="imgReplaceInput" hidden accept="image/*" />

    <header class="h-14 bg-white border-b border-gray-200 flex items-center justify-between px-4 shadow-sm z-30 shrink-0 text-sm">
      <div class="flex items-center gap-4">
        <div class="flex items-center gap-2 text-slate-800 cursor-pointer" onclick="App.ui.showModal('welcomeModal')">
          <i class="ph ph-scroll text-2xl text-red-600"></i>
          <span class="font-bold tracking-tight">PaperStudio</span>
        </div>
        <div class="flex items-center gap-1">
          <button onclick="document.getElementById('projectImportInput').click()" class="hover:bg-gray-100 px-2 py-1 rounded font-medium flex items-center gap-1 transition text-slate-600" title="打开 (Ctrl+O)">
            <i class="ph ph-folder-open text-lg"></i> 打开
          </button>
          <button onclick="App.io.saveProject()" class="hover:bg-gray-100 px-2 py-1 rounded font-medium flex items-center gap-1 transition text-slate-600" title="保存 (Ctrl+S)">
            <i class="ph ph-floppy-disk text-lg"></i> 保存
          </button>
          <div class="w-px h-4 bg-gray-300 mx-1"></div>
          <button
            id="btnUndo"
            onclick="App.history.undo()"
            disabled
            class="hover:bg-gray-100 px-2 py-1 rounded font-medium flex items-center gap-1 transition text-slate-600 disabled:opacity-40 disabled:cursor-not-allowed disabled:hover:bg-transparent"
            title="撤销 (Ctrl+Z)"
          >
            <i class="ph ph-arrow-u-up-left text-lg"></i>
          </button>
          <button
            id="btnRedo"
            onclick="App.history.redo()"
            disabled
            class="hover:bg-gray-100 px-2 py-1 rounded font-medium flex items-center gap-1 transition text-slate-600 disabled:opacity-40 disabled:cursor-not-allowed disabled:hover:bg-transparent"
            title="重做 (Ctrl+Y)"
          >
            <i class="ph ph-arrow-u-up-right text-lg"></i>
          </button>
        </div>
      </div>

      <div class="flex items-center gap-1">
        <button onclick="App.tools.addText()" class="flex items-center gap-1 px-3 py-1.5 rounded hover:bg-gray-100 font-medium transition text-gray-600"><i class="ph ph-text-t text-lg"></i> 文字</button>
        <button onclick="App.tools.addParagraph()" class="flex items-center gap-1 px-3 py-1.5 rounded hover:bg-gray-100 font-medium transition text-gray-600"><i class="ph ph-text-align-justify text-lg"></i> 段落</button>

        <button onclick="document.getElementById('imgUpload').click()" class="flex items-center gap-1 px-3 py-1.5 rounded hover:bg-gray-100 font-medium transition text-gray-600">
          <i class="ph ph-image text-lg"></i> 图片
        </button>

        <div class="relative dropdown">
          <button class="flex items-center gap-1 px-3 py-1.5 rounded hover:bg-gray-100 font-medium transition text-gray-600">
            <i class="ph ph-article-ny-times text-lg"></i> 预设文本 <i class="ph ph-caret-down"></i>
          </button>
          <div class="dropdown-menu">
            <button onclick="App.tools.addDate()" class="flex items-center gap-1 px-3 py-1.5 rounded hover:bg-gray-100 font-medium transition text-gray-600"><i class="ph ph-calendar text-lg"></i> 日期</button>
            <button onclick="App.tools.addPageNum()" class="flex items-center gap-1 px-3 py-1.5 rounded hover:bg-gray-100 font-medium transition text-gray-600"><i class="ph ph-hash text-lg"></i> 页码</button>
          </div>
        </div>

        <div class="relative dropdown">
          <button class="flex items-center gap-1 px-3 py-1.5 rounded hover:bg-gray-100 font-medium transition text-gray-600"><i class="ph ph-shapes text-lg"></i> 图形 <i class="ph ph-caret-down"></i></button>
          <div class="dropdown-menu">
            <button onclick="App.tools.addLine()" class="flex items-center gap-1 px-3 py-1.5 rounded hover:bg-gray-100 font-medium transition text-gray-600"><i class="ph ph-line-segment text-lg"></i> 线条</button>
            <button onclick="App.tools.addShape('rect')" class="w-full text-left px-2 py-2 hover:bg-gray-100 flex items-center gap-2"><i class="ph ph-rectangle"></i> 矩形</button>
            <button onclick="App.tools.addShape('circle')" class="w-full text-left px-2 py-2 hover:bg-gray-100 flex items-center gap-2"><i class="ph ph-circle"></i> 圆形</button>
            <button onclick="App.tools.addShape('triangle')" class="w-full text-left px-2 py-2 hover:bg-gray-100 flex items-center gap-2"><i class="ph ph-triangle"></i> 三角形</button>
            <button onclick="App.tools.addShape('star')" class="w-full text-left px-2 py-2 hover:bg-gray-100 flex items-center gap-2"><i class="ph ph-star"></i> 角形</button>
          </div>
        </div>
      </div>

      <div class="w-80 flex justify-end gap-2">
        <button onclick="App.ui.toggleFullScreen()" class="flex items-center gap-1 px-3 py-1.5 rounded hover:bg-gray-100 text-md font-medium transition text-gray-600" title="全屏模式">
          <i id="fsIcon" class="ph ph-corners-out text-lg"></i>
        </button>
        <button onclick="App.io.exportPDF()" class="bg-white border border-red-200 text-red-600 hover:bg-red-50 px-3 py-1.5 rounded flex items-center gap-1 shadow-sm transition">
          <i class="ph ph-file-pdf text-lg"></i> 导出 PDF
        </button>
        <button onclick="App.io.print()" class="bg-red-600 hover:bg-red-700 text-white px-3 py-1.5 rounded flex items-center gap-1 shadow-sm transition" title="打印 (Ctrl+P)">
          <i class="ph ph-printer text-lg"></i> 打印
        </button>
      </div>
    </header>

    <div class="flex-1 flex overflow-hidden">
      <aside class="w-64 bg-white border-r border-gray-200 flex flex-col z-20 overflow-y-auto no-scrollbar text-xs">
        <div class="p-4 space-y-6">
          <section>
            <h3 class="font-bold text-gray-400 uppercase tracking-wider mb-3 flex items-center gap-1 text-sm"><i class="ph ph-files"></i> 纸张布局</h3>
            <div class="space-y-3">
              <div>
                <label class="compact-label">纸张尺寸</label>
                <select id="paperSize" onchange="App.paper.updateSize()" class="w-full border-gray-300 rounded-md border p-2 bg-gray-50">
                  <option value="A3">A3 (297 × 420 mm)</option>
                  <option value="A4" selected>A4 (210 × 297 mm)</option>
                  <option value="A5">A5 (148 × 210 mm)</option>
                  <option value="B4">B4 (250 × 353 mm)</option>
                  <option value="B5">B5 (176 × 250 mm)</option>
                  <option value="Letter">Letter 美信</option>
                  <option value="Legal">Legal 美长</option>
                  <option value="16开">16开 (210 × 285 mm)</option>
                  <option value="32开">32开 (185 × 260 mm)</option>
                  <option value="方信笺纸">方信笺纸 (230 × 230 mm)</option>
                  <hr class="my-2 border-gray-300" />
                  <option value="CUSTOM">自定义尺寸…</option>
                </select>
                <label class="flex items-center gap-1 cursor-pointer mt-3 select-none">
                  <input type="checkbox" id="paperOrientation" class="accent-red-600 rounded scale-90" onchange="App.paper.updateSize()" />
                  <span class="text-gray-600">横向</span>
                </label>
              </div>
              <div id="customSizeInputs" class="grid grid-cols-2 gap-2 hidden">
                <div><label class="compact-label">宽 (mm)</label><input type="number" id="customW" value="210" class="w-full compact-input border rounded" /></div>
                <div><label class="compact-label">高 (mm)</label><input type="number" id="customH" value="297" class="w-full compact-input border rounded" /></div>
                <button onclick="App.paper.updateSize()" class="col-span-2 bg-gray-100 hover:bg-gray-200 py-1 rounded">应用尺寸</button>
              </div>
              <div class="grid grid-cols-2 gap-2">
                <div><label class="compact-label">上边距</label><input type="number" id="marginTop" value="35" min="0" class="w-full compact-input border border-gray-300 rounded" oninput="App.paper.drawGrid()" /></div>
                <div>
                  <label class="compact-label">下边距</label><input type="number" id="marginBottom" value="30" min="0" class="w-full compact-input border border-gray-300 rounded" oninput="App.paper.drawGrid()" />
                </div>
                <div><label class="compact-label">左边距</label><input type="number" id="marginLeft" value="22" min="0" class="w-full compact-input border border-gray-300 rounded" oninput="App.paper.drawGrid()" /></div>
                <div><label class="compact-label">右边距</label><input type="number" id="marginRight" value="22" min="0" class="w-full compact-input border border-gray-300 rounded" oninput="App.paper.drawGrid()" /></div>
              </div>
            </div>
          </section>
          <section>
            <div class="space-y-3">
              <div>
                <div class="flex justify-between mb-1">
                  <label class="compact-label">行数</label>
                  <span class="font-mono bg-red-50 text-red-600 px-1 rounded" id="rowCountDisplay">20</span>
                </div>
                <input type="range" id="rowCount" min="0" max="50" value="20" class="w-full accent-red-600 h-1.5 bg-gray-200 rounded-lg appearance-none cursor-pointer" oninput="App.paper.updateSettings()" />
              </div>
              <div class="flex items-center gap-2">
                <div class="flex-1">
                  <label class="compact-label">背景颜色</label>
                  <div class="flex items-center gap-2">
                    <input type="color" id="paperBgColor" value="#ffffff" oninput="App.paper.drawGrid()" class="h-7 w-full p-0 border-0 rounded cursor-pointer" />
                    <button onclick="document.getElementById('paperBgColor').value='#ffffff'; App.paper.drawGrid()" class="px-2 py-1 bg-gray-100 hover:bg-gray-200 rounded text-xs" title="重置为白色">
                      <i class="ph ph-arrow-counter-clockwise"></i>
                    </button>
                  </div>
                </div>

                <div class="flex-1">
                  <label class="compact-label">行线颜色</label>
                  <input type="color" id="gridColor" value="#e11d48" class="h-7 w-full p-0 border-0 rounded cursor-pointer" oninput="App.paper.updateSettings()" />
                </div>
                <div class="w-16">
                  <label class="compact-label">线宽</label>
                  <input type="number" id="strokeWidth" value="1" min="1" max="5" class="w-full compact-input border rounded" oninput="App.paper.updateSettings()" />
                </div>
              </div>
              <div class="flex items-center gap-2 mt-2">
                <label class="flex items-center gap-2 cursor-pointer flex-1 select-none">
                  <input type="checkbox" id="gridDashed" class="accent-red-600 rounded scale-90" onchange="App.paper.updateSettings()" />
                  <span class="text-gray-600 compact-label mb-0">虚线</span>
                </label>
                <div class="w-16 relative">
                  <span class="text-gray-300 pointer-events-none">间距</span>
                  <input type="number" id="gridDashArray" value="4" min="1" max="20" class="w-full compact-input border rounded" oninput="App.paper.updateSettings()" />
                </div>
              </div>
              <div class="space-y-1">
                <label class="flex items-center gap-2 cursor-pointer"
                  ><input type="checkbox" id="doubleFirst" class="accent-red-600 rounded scale-90" onchange="App.paper.drawGrid()" checked /><span class="text-gray-600">首行双线</span></label
                >
                <label class="flex items-center gap-2 cursor-pointer"
                  ><input type="checkbox" id="doubleLast" class="accent-red-600 rounded scale-90" onchange="App.paper.drawGrid()" checked /><span class="text-gray-600">尾行双线</span></label
                >
              </div>
            </div>
          </section>
        </div>
      </aside>

      <main class="flex-1 bg-gray-200 relative flex flex-col overflow-hidden">
        <div class="absolute top-4 right-4 z-20 flex items-center bg-white shadow-lg rounded-lg p-1 border border-gray-200 text-xs">
          <button onclick="App.zoom.change(-0.1)" class="w-7 h-7 flex items-center justify-center text-gray-600 hover:bg-gray-100 rounded transition"><i class="ph ph-minus"></i></button>
          <span id="zoomPercent" class="font-mono w-12 text-center text-gray-600 font-bold">100%</span>
          <button onclick="App.zoom.change(0.1)" class="w-7 h-7 flex items-center justify-center text-gray-600 hover:bg-gray-100 rounded transition"><i class="ph ph-plus"></i></button>
          <div class="w-px h-3 bg-gray-300 mx-1"></div>
          <button onclick="App.zoom.autoFit()" class="w-7 h-7 flex items-center justify-center text-gray-600 hover:bg-gray-100 rounded transition" title="自适应"><i class="ph ph-arrows-out-simple"></i></button>
        </div>

        <div id="scrollContainer" class="flex-1 overflow-auto custom-scrollbar relative">
          <div id="zoomViewport">
            <div id="canvasWrapper" class="shadow-2xl bg-white relative">
              <canvas id="paperCanvas"></canvas>
              <button
                id="bgClearBtn"
                onclick="App.paper.clearBackground()"
                class="hidden absolute top-2 right-2 z-10 bg-white/90 hover:bg-red-50 text-gray-400 hover:text-red-600 rounded-full p-1 shadow-sm border border-gray-200 transition"
              >
                <i class="ph ph-trash text-lg"></i>
              </button>
            </div>
          </div>
        </div>

        <div class="h-5 bg-white border-t border-gray-200 flex items-center justify-between px-3 text-gray-400 shrink-0 z-20 text-xs">
          <span id="canvasSizeLabel">A4</span>
          <span class="flex items-center"><i class="ph ph-mouse-left-click"></i>拖动平移 | 滚轮缩放 | Shift+点击 多选 | Alt+拉框 多选</span>
        </div>
      </main>

      <aside class="w-64 bg-white border-l border-gray-200 flex flex-col z-20 h-full text-xs">
        <div class="flex-1 flex flex-col border-b border-gray-200 overflow-hidden" style="min-height: 45%">
          <div class="h-8 border-b border-gray-100 flex items-center px-3 bg-gray-50/50 shrink-0">
            <span class="font-bold text-gray-500 uppercase tracking-wider text-sm">选中属性</span>
          </div>

          <div id="noSelection" class="flex-1 flex flex-col items-center justify-center text-gray-300 p-8 text-center">
            <i class="ph ph-cursor-click text-4xl mb-2"></i>
            <p class="">选中元素以编辑</p>
          </div>

          <div id="selectionControls" class="hidden flex-1 overflow-y-auto p-3 space-y-4 text-xs">
            <section id="geoProps" class="border-b border-gray-100 pb-3">
              <div class="grid grid-cols-3 gap-2 mb-2">
                <div><label class="compact-label">X 坐标</label><input type="number" id="propX" class="w-full compact-input border rounded" onchange="App.ui.updateGeo('left', this.value)" /></div>
                <div><label class="compact-label">Y 坐标</label><input type="number" id="propY" class="w-full compact-input border rounded" onchange="App.ui.updateGeo('top', this.value)" /></div>
                <div><label class="compact-label">旋转°</label><input type="number" id="propAngle" class="w-full compact-input border rounded" onchange="App.ui.updateGeo('angle', this.value)" /></div>
              </div>
              <div class="grid grid-cols-2 gap-2">
                <div><label class="compact-label">宽度</label><input type="number" id="propW" class="w-full compact-input border rounded" onchange="App.ui.updateGeo('width', this.value)" /></div>
                <div><label class="compact-label">高度</label><input type="number" id="propH" class="w-full compact-input border rounded" onchange="App.ui.updateGeo('height', this.value)" /></div>
              </div>
            </section>

            <section id="commonProps" class="border-b border-gray-100 pb-3">
              <label class="compact-label flex justify-between"><span>透明度</span> <span id="opacityVal" class="text-gray-400">100%</span></label>
              <input
                type="range"
                id="propOpacity"
                min="0"
                max="1"
                step="0.01"
                oninput="App.ui.setProp('opacity', parseFloat(this.value)); 
                document.getElementById('opacityVal').innerText=Math.round(this.value*100)+'%'"
                class="w-full accent-slate-600 h-1 bg-gray-200 rounded appearance-none"
              />
            </section>

            <section id="alignTools" class="hidden border-b border-gray-100 pb-3">
              <h4 class="font-bold text-blue-600 mb-2">对齐与分布</h4>
              <div class="grid grid-cols-4 gap-1">
                <button onclick="App.ui.align('left')" class="py-1 border rounded hover:bg-blue-50" title="左对齐"><i class="ph ph-align-left"></i></button>
                <button onclick="App.ui.align('center')" class="py-1 border rounded hover:bg-blue-50" title="水平居中"><i class="ph ph-align-center-horizontal"></i></button>
                <button onclick="App.ui.align('right')" class="py-1 border rounded hover:bg-blue-50" title="右对齐"><i class="ph ph-align-right"></i></button>
                <button onclick="App.ui.distribute('horizontal')" class="py-1 border rounded hover:bg-blue-50" title="水平平均分布"><i class="ph ph-columns"></i></button>
                <button onclick="App.ui.align('top')" class="py-1 border rounded hover:bg-blue-50" title="顶对齐"><i class="ph ph-align-top"></i></button>
                <button onclick="App.ui.align('middle')" class="py-1 border rounded hover:bg-blue-50" title="垂直居中"><i class="ph ph-align-center-vertical"></i></button>
                <button onclick="App.ui.align('bottom')" class="py-1 border rounded hover:bg-blue-50" title="底对齐"><i class="ph ph-align-bottom"></i></button>
                <button onclick="App.ui.distribute('vertical')" class="py-1 border rounded hover:bg-blue-50" title="垂直平均分布"><i class="ph ph-rows"></i></button>
              </div>
            </section>

            <section id="textProps" class="hidden space-y-2">
              <div class="flex gap-1 items-end">
                <div class="flex-1">
                  <label class="compact-label">字体</label>
                  <select id="propFont" onchange="App.ui.setProp('fontFamily', this.value)" onclick="App.loadLocalFonts()" class="w-full compact-input border rounded bg-white">
                    <option value="SourceHanSerifCN-Bold" style="font-family: 'SourceHanSerifCN-Bold'">思源宋体</option>
                    <option value="SimSun">宋体</option>
                    <option value="KaiTi">楷体</option>
                    <option value="SimHei">黑体</option>
                    <option value="FangSong">仿宋</option>
                    <option value="Arial">Arial</option>
                    <option value="'Times New Roman'">Times New Roman</option>
                  </select>
                </div>
                <div class="w-16">
                  <label class="compact-label">字号</label>
                  <input type="number" id="propSize" oninput="App.ui.setProp('fontSize', Utils.pt2px(this.value))" class="w-full compact-input border rounded" />
                </div>
              </div>
              <div class="flex gap-2 items-center">
                <div class="flex border rounded overflow-hidden shrink-0">
                  <button id="btnBold" onclick="App.ui.toggleStyle('bold')" class="style-btn hover:bg-gray-50 border-r"><i class="ph ph-text-b"></i></button>
                  <button id="btnItalic" onclick="App.ui.toggleStyle('italic')" class="style-btn hover:bg-gray-50 border-r"><i class="ph ph-text-italic"></i></button>
                  <button id="btnUnderline" onclick="App.ui.toggleStyle('underline')" class="style-btn hover:bg-gray-50"><i class="ph ph-text-underline"></i></button>
                </div>
                <div class="flex-1 h-7 border rounded p-0.5 overflow-hidden flex items-center relative">
                  <input type="color" id="propColor" oninput="App.ui.setProp('fill', this.value)" class="absolute -top-2 -left-2 w-[150%] h-20 cursor-pointer p-0 border-0" />
                </div>
              </div>
              <div class="flex border rounded overflow-hidden flex-1">
                <button onclick="App.ui.setProp('textAlign', 'left')" class="flex-1 py-1 hover:bg-gray-50 border-r flex justify-center"><i class="ph ph-text-align-left"></i></button>
                <button onclick="App.ui.setProp('textAlign', 'center')" class="flex-1 py-1 hover:bg-gray-50 border-r flex justify-center"><i class="ph ph-text-align-center"></i></button>
                <button onclick="App.ui.setProp('textAlign', 'right')" class="flex-1 py-1 hover:bg-gray-50 flex justify-center"><i class="ph ph-text-align-right"></i></button>
              </div>
              <div>
                <label class="compact-label flex justify-between"><span>行高</span> <span id="lineHeightVal">1.2</span></label>
                <input
                  type="range"
                  id="propLineHeight"
                  min="0.5"
                  max="3.0"
                  step="0.1"
                  value="1.2"
                  oninput="App.ui.setProp('lineHeight', parseFloat(this.value)); document.getElementById('lineHeightVal').innerText=this.value"
                  class="w-full accent-slate-600 h-1 bg-gray-200 rounded appearance-none"
                />
              </div>
              <div>
                <label class="compact-label flex justify-between"><span>字间距</span> <span id="charSpacingVal">0</span></label>
                <input
                  type="range"
                  id="propCharSpacing"
                  min="-200"
                  max="1000"
                  step="10"
                  oninput="App.ui.setProp('charSpacing', parseInt(this.value)); document.getElementById('charSpacingVal').innerText=this.value"
                  class="w-full accent-slate-600 h-1 bg-gray-200 rounded appearance-none"
                />
              </div>
            </section>
            <section id="lineProps" class="hidden space-y-2">
              <div class="flex items-center gap-2">
                <div class="flex-1">
                  <label class="compact-label">线颜色</label>
                  <div class="flex-1 h-7 border rounded p-0.5 overflow-hidden flex items-center relative">
                    <input type="color" id="lineColor" oninput="App.ui.setProp('stroke', this.value)" class="absolute -top-2 -left-2 w-[150%] h-20 cursor-pointer p-0 border-0" />
                  </div>
                </div>
                <div class="w-16">
                  <label class="compact-label">线宽</label>
                  <input type="number" id="lineStrokeWidth" min="1" max="50" oninput="App.ui.setProp('strokeWidth', parseInt(this.value))" class="w-full compact-input border rounded" />
                </div>
              </div>

              <div class="flex items-center gap-2 pt-1 border-t border-gray-100">
                <label class="flex items-center gap-2 cursor-pointer flex-1 select-none">
                  <input type="checkbox" id="lineDashCheck" class="accent-slate-600 rounded scale-90" onchange="App.ui.updateLineDash()" />
                  <span class="text-gray-600 compact-label mb-0">虚线</span>
                </label>
                <div class="w-16">
                  <label class="compact-label">虚线间距</label>
                  <input type="number" id="lineDashVal" value="5" min="1" max="50" class="w-full compact-input border rounded" oninput="App.ui.updateLineDash()" />
                </div>
              </div>
            </section>

            <section id="shapeProps" class="hidden space-y-3 border-b border-gray-100 pb-3">
              <!-- 原有的填充/边框颜色控制保持不变 -->
              <div class="flex gap-2">
                <div class="flex-1">
                  <label class="compact-label">填充</label>
                  <div class="h-8 border rounded p-0.5 overflow-hidden relative bg-white">
                    <input type="color" id="shapeFill" oninput="App.ui.setProp('fill', this.value)" class="absolute -top-2 -left-2 w-[150%] h-16 cursor-pointer" />
                  </div>
                </div>
                <div class="flex-1">
                  <label class="compact-label">边框</label>
                  <div class="h-8 border rounded p-0.5 overflow-hidden relative bg-white">
                    <input type="color" id="shapeStroke" oninput="App.ui.setProp('stroke', this.value)" class="absolute -top-2 -left-2 w-[150%] h-16 cursor-pointer" />
                  </div>
                </div>
                <div class="w-16">
                  <label class="compact-label">线宽</label>
                  <input type="number" id="shapeStrokeWidth" min="0" max="20" class="w-full compact-input border rounded" oninput="App.ui.setProp('strokeWidth', parseInt(this.value))" />
                </div>
              </div>

              <!-- 新增：高级角控制区 (只对矩形/智能路径显示) -->
              <div id="rectCornerControl" class="hidden space-y-2 pt-2 border-t border-gray-200">
                <!-- 类型选择与总控 -->
                <div class="flex items-end gap-2">
                  <div class="w-1/3">
                    <label class="compact-label">角类型</label>
                    <select id="cornerStyle" onchange="App.tools.updateSmartCorner('style', this.value)" class="w-full compact-input border rounded bg-white">
                      <option value="round">圆角</option>
                      <option value="bevel">斜角</option>
                    </select>
                  </div>
                  <div class="flex-1">
                    <label class="compact-label flex justify-between"><span>角尺寸</span><span id="masterRadiusVal" class="text-xs text-gray-400">0</span></label>
                    <input
                      type="range"
                      id="masterRadius"
                      min="0"
                      max="100"
                      value="0"
                      oninput="App.tools.updateSmartCorner('all', this.value)"
                      class="w-full accent-red-600 h-1.5 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                    />
                  </div>
                </div>

                <div class="grid grid-cols-2 gap-2 bg-gray-50 p-2 rounded border border-gray-200">
                  <div class="relative">
                    <span class="absolute left-1 top-1 text-[10px] text-gray-400">左上</span>
                    <input type="number" id="cornerTL" min="0" oninput="App.tools.updateSmartCorner('tl', this.value)" class="w-full compact-input border rounded text-right pl-6" />
                  </div>
                  <div class="relative">
                    <span class="absolute left-1 top-1 text-[10px] text-gray-400">右上</span>
                    <input type="number" id="cornerTR" min="0" oninput="App.tools.updateSmartCorner('tr', this.value)" class="w-full compact-input border rounded text-right pl-6" />
                  </div>
                  <div class="relative">
                    <span class="absolute left-1 top-1 text-[10px] text-gray-400">左下</span>
                    <input type="number" id="cornerBL" min="0" oninput="App.tools.updateSmartCorner('bl', this.value)" class="w-full compact-input border rounded text-right pl-6" />
                  </div>
                  <div class="relative">
                    <span class="absolute left-1 top-1 text-[10px] text-gray-400">右下</span>
                    <input type="number" id="cornerBR" min="0" oninput="App.tools.updateSmartCorner('br', this.value)" class="w-full compact-input border rounded text-right pl-6" />
                  </div>
                </div>
              </div>
            </section>

            <section id="imgProps" class="hidden">
              <button onclick="document.getElementById('imgReplaceInput').click()" class="w-full py-2 bg-gray-100 text-slate-700 border border-gray-300 rounded font-medium hover:bg-gray-200 transition mb-2">
                <i class="ph ph-arrows-clockwise"></i> 替换图片
              </button>

              <button onclick="App.tools.setAsBackground()" class="w-full py-2 bg-blue-50 text-blue-600 border border-blue-200 rounded font-medium hover:bg-blue-100 transition mb-3">
                <i class="ph ph-image-square"></i> 设为背景图片
              </button>
            </section>

            <section id="fineTuneTools">
              <h4 class="font-bold text-gray-400 mb-2 border-t pt-2">微调与布局</h4>
              <div class="grid grid-cols-3 gap-1 mb-2 w-28 mx-auto">
                <button onclick="App.tools.flip('x')" class="py-1.5 border rounded hover:bg-gray-50 flex items-center justify-center gap-1">
                  <i class="ph ph-flip-horizontal"></i>
                </button>
                <button onclick="App.tools.nudge('up')" class="p-1 border rounded hover:bg-gray-100 flex items-center justify-center h-7"><i class="ph ph-caret-up"></i></button>
                <button onclick="App.tools.flip('y')" class="py-1.5 border rounded hover:bg-gray-50 flex items-center justify-center gap-1">
                  <i class="ph ph-flip-vertical"></i>
                </button>
                <button onclick="App.tools.nudge('left')" class="p-1 border rounded hover:bg-gray-100 flex items-center justify-center h-7"><i class="ph ph-caret-left"></i></button>
                <button onclick="App.tools.nudge('down')" class="p-1 border rounded hover:bg-gray-100 flex items-center justify-center h-7"><i class="ph ph-caret-down"></i></button>
                <button onclick="App.tools.nudge('right')" class="p-1 border rounded hover:bg-gray-100 flex items-center justify-center h-7"><i class="ph ph-caret-right"></i></button>
                <button onclick="App.ui.alignObject('left')" class="p-1 border rounded hover:bg-gray-100 flex items-center justify-center h-7"><i class="ph ph-align-left-simple"></i></button>
                <button onclick="App.ui.alignObject('centerH')" class="p-1 border rounded hover:bg-gray-100 flex items-center justify-center h-7"><i class="ph ph-align-center-horizontal-simple"></i></button>
                <button onclick="App.ui.alignObject('right')" class="p-1 border rounded hover:bg-gray-100 flex items-center justify-center h-7"><i class="ph ph-align-right-simple"></i></button>
              </div>
            </section>
          </div>
        </div>

        <div class="flex-1 flex flex-col overflow-hidden bg-gray-50/50">
          <div class="h-8 border-b border-gray-200 flex items-center px-3 bg-gray-100 shrink-0"><span class="font-bold text-gray-500 uppercase text-sm">图层</span></div>
          <div id="layerList" class="flex-1 overflow-y-auto p-1 space-y-0.5 custom-scrollbar"></div>
          <div class="h-9 border-t border-gray-200 bg-white flex items-center justify-around px-2 shrink-0">
            <button class="p-1 text-gray-500 hover:text-blue-600 hover:bg-blue-50 rounded" onclick="App.ui.moveLayer('up')" title="上移"><i class="ph ph-arrow-up"></i></button>
            <button class="p-1 text-gray-500 hover:text-blue-600 hover:bg-blue-50 rounded" onclick="App.ui.moveLayer('down')" title="下移"><i class="ph ph-arrow-down"></i></button>
            <div class="w-px h-3 bg-gray-300"></div>
            <button class="p-1 text-gray-500 hover:text-red-600 hover:bg-red-50 rounded" onclick="App.tools.deleteActive()" title="删除 (Delete)"><i class="ph ph-trash"></i></button>
          </div>
        </div>
      </aside>
    </div>
    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="hidden fixed inset-0 z-[60] bg-white/80 backdrop-blur-sm flex flex-col items-center justify-center">
      <div class="animate-spin rounded-full h-12 w-12 border-4 border-red-600 border-t-transparent"></div>
      <p class="mt-4 text-slate-600 font-medium animate-pulse">正在加载模板...</p>
    </div>
    <script>
      // --- 1. 配置与常量 ---
      const CONFIG = {
        DPI: 96,
        MM_TO_PX: 3.7795, // 1mm = 3.7795px
        PT_TO_PX: 1.3333, // 1pt = 1.3333px
        CANVAS_MARGIN_Y: 40,
        SIZES: {
          A3: { w: 297, h: 420 },
          A4: { w: 210, h: 297 },
          A5: { w: 148, h: 210 },
          A6: { w: 105, h: 148 },
          B4: { w: 250, h: 353 },
          B5: { w: 176, h: 250 },
          Letter: { w: 215.9, h: 279.4 },
          Legal: { w: 215.9, h: 355.6 },
          "16开": { w: 210, h: 285 },
          "32开": { w: 185, h: 260 },
          大32开: { w: 203, h: 276 },
          方信笺纸: { w: 230, h: 230 },
        },
      };

      // --- 2. 工具类 ---
      const Utils = {
        mm2px: (mm) => mm * CONFIG.MM_TO_PX,
        px2mm: (px) => px / CONFIG.MM_TO_PX,
        pt2px: (pt) => Math.round(pt * CONFIG.PT_TO_PX),
        px2pt: (px) => Math.round(px / CONFIG.PT_TO_PX),

        // 使用 Toastify 显示提示消息
        toast: (msg, type = "info") => {
          let bg = type === "error" ? "linear-gradient(to right, #ff5f6d, #ffc371)" : type === "success" ? "linear-gradient(to right, #00b09b, #96c93d)" : "#333";
          Toastify({
            text: msg,
            duration: 3000,
            gravity: "top",
            position: "center",
            style: { background: bg, borderRadius: "8px", fontSize: "12px", boxShadow: "0 4px 6px rgba(0,0,0,0.1)" },
          }).showToast();
        },

        // 节流函数 (优化 resize 事件)
        throttle: (func, limit) => {
          let inThrottle;
          return function () {
            const args = arguments;
            const context = this;
            if (!inThrottle) {
              func.apply(context, args);
              inThrottle = true;
              setTimeout(() => (inThrottle = false), limit);
            }
          };
        },
        generateSmartRectPath: (w, h, r, style) => {
          // r 是对象 { tl, tr, br, bl }
          // 限制半径不超过宽高的一半，防止重叠渲染错误
          const maxR = Math.min(w, h) / 2;
          const tl = Math.min(r.tl, maxR);
          const tr = Math.min(r.tr, maxR);
          const br = Math.min(r.br, maxR);
          const bl = Math.min(r.bl, maxR);

          let path = `M ${tl} 0 L ${w - tr} 0 `;

          if (style === "round") {
            // 圆角 (Arc): A rx ry rotation large-arc sweep x y
            if (tr > 0) path += `A ${tr} ${tr} 0 0 1 ${w} ${tr} `;
            else path += `L ${w} 0 `;

            path += `L ${w} ${h - br} `;

            if (br > 0) path += `A ${br} ${br} 0 0 1 ${w - br} ${h} `;
            else path += `L ${w} ${h} `;

            path += `L ${bl} ${h} `;

            if (bl > 0) path += `A ${bl} ${bl} 0 0 1 0 ${h - bl} `;
            else path += `L 0 ${h} `;

            path += `L 0 ${tl} `;

            if (tl > 0) path += `A ${tl} ${tl} 0 0 1 ${tl} 0 `;
            else path += `L 0 0 `;
          } else {
            // 斜角 (Bevel): 使用 LineTo 直接切角
            path += `L ${w} ${tr} `;
            path += `L ${w} ${h - br} `;
            path += `L ${w - br} ${h} `;
            path += `L ${bl} ${h} `;
            path += `L 0 ${h - bl} `;
            path += `L 0 ${tl} `;
            path += `L ${tl} 0 `;
          }

          path += "Z";
          return path;
        },
      };

      // --- 3. App 主逻辑 ---
      const App = {
        canvas: null,

        state: {
          currentPaper: { ...CONFIG.SIZES["A4"] },
          baseWidth: 0, // 100% 缩放下的像素宽
          baseHeight: 0, // 100% 缩放下的像素高
          zoom: 1,
          isPanning: false,
          clipboard: null, // 剪贴板数据
          lastGridSettings: {},
          pasteCount: 0,
          selectionQueue: [], // 维护多选顺序,
          localFontsLoaded: false,
          hasUnsavedChanges: false,
        },

        // --- 初始化 ---
        init: function () {
          // 初始化 Fabric Canvas
          this.canvas = new fabric.Canvas("paperCanvas", {
            backgroundColor: "#fff",
            preserveObjectStacking: true,
            selection: true,
            enableRetinaScaling: true,
            fireRightClick: true,
            stopContextMenu: true,
            defaultCursor: "default",
            hoverCursor: "move",
          });

          // 配置全局对象样式
          fabric.Object.prototype.set({
            borderColor: "#3b82f6",
            borderScaleFactor: 1.5,
            cornerColor: "white",
            cornerStrokeColor: "#3b82f6",
            borderOpacityWhenMoving: 1,
            cornerSize: 8,
            transparentCorners: false,
            centeredScaling: false,
            uniformScaling: false,
            uniScaleKey: "shiftKey",
          });
          // 初始化子模块
          this.paper.init();
          this.events.initCanvasEvents();
          this.history.init();
          this.zoom.autoFit();

          // 加载本地字体
          if ("queryLocalFonts" in window) {
            setTimeout(this.loadLocalFonts, 1000);
          }

          console.log("App Initialized");
        },

        // --- 历史记录模块 (Undo/Redo) ---
        history: {
          stack: [],
          index: -1,
          locked: false, // 锁定状态，用于防止程序内部操作（如加载模版）触发保存
          maxSteps: 20,

          init: function () {
            const saveHandler = () => {
              // 只有在非锁定状态下才保存
              if (!this.locked) this.saveState();
            };

            App.canvas.on("object:modified", saveHandler);
            App.canvas.on("object:added", (e) => {
              // 排除网格线和非锁定状态
              if (e.target && !e.target.isGrid && !this.locked) saveHandler();
            });
            App.canvas.on("object:removed", (e) => {
              if (e.target && !e.target.isGrid && !this.locked) saveHandler();
            });

            // 注意：这里去掉了原来 init 中的 this.saveState()，防止刚打开就算一次操作
          },

          updateUI: function () {
            const btnUndo = document.getElementById("btnUndo");
            const btnRedo = document.getElementById("btnRedo");
            if (!btnUndo || !btnRedo) return;

            // 只有当 index > 0 时才能撤销（保留初始状态不被撤销删除）
            btnUndo.disabled = this.index <= 0;
            btnRedo.disabled = this.index >= this.stack.length - 1;
          },

          saveState: function () {
            if (this.locked) return;

            // 如果在撤销状态下进行了新操作，清除后面的记录
            if (this.index < this.stack.length - 1) {
              this.stack = this.stack.slice(0, this.index + 1);
            }

            const json = App.canvas.toJSON(["id", "isGrid", "selectable", "evented", "lockMovementX", "lockMovementY", "cornerConfig", "isSmartRect"]);
            json.objects = json.objects.filter((o) => !o.isGrid);

            this.stack.push(JSON.stringify(json));

            if (this.stack.length > this.maxSteps) {
              this.stack.shift();
            } else {
              this.index++;
            }

            this.updateUI();
            App.state.hasUnsavedChanges = true;
          },

          // 新增：重置历史记录（用于加载模版后）
          reset: function () {
            this.stack = [];
            this.index = -1;
            this.locked = false;
            this.saveState(); // 保存当前画面为“初始状态” (Index 0)
            this.updateUI(); // 此时 Index 为 0，Undo 按钮应为禁用状态
          },

          undo: function () {
            /* 保持原样 */
            if (this.index <= 0) return;
            this.index--;
            this.load(this.stack[this.index]);
            this.updateUI();
          },

          redo: function () {
            /* 保持原样 */
            if (this.index >= this.stack.length - 1) return;
            this.index++;
            this.load(this.stack[this.index]);
            this.updateUI();
          },

          load: function (jsonStr) {
            this.locked = true; // 加载历史时锁定，防止循环触发保存
            App.canvas.loadFromJSON(jsonStr, () => {
              App.paper.drawGrid();
              App.canvas.renderAll();
              App.ui.updateLayerList();
              App.ui.updateInspector(); // 更新属性面板
              this.locked = false;
            });
          },
        },

        // --- 纸张与网格管理 ---
        paper: {
          init: function () {
            this.updateSize();
          },

          // 获取当前UI配置
          getSettings: function () {
            const getVal = (id, def) => (document.getElementById(id) ? document.getElementById(id).value : def);
            const getCheck = (id) => (document.getElementById(id) ? document.getElementById(id).checked : false);

            return {
              marginTop: parseInt(getVal("marginTop", 37)) * CONFIG.MM_TO_PX,
              marginBottom: parseInt(getVal("marginBottom", 35)) * CONFIG.MM_TO_PX,
              marginLeft: parseInt(getVal("marginLeft", 28)) * CONFIG.MM_TO_PX,
              marginRight: parseInt(getVal("marginRight", 26)) * CONFIG.MM_TO_PX,
              rowCount: parseInt(getVal("rowCount", 20)),
              gridColor: getVal("gridColor", "#e11d48"),
              strokeWidth: parseInt(getVal("strokeWidth", 1)),
              doubleFirst: getCheck("doubleFirst"),
              doubleLast: getCheck("doubleLast"),
              gridDashed: getCheck("gridDashed"),
              gridDashArray: parseInt(getVal("gridDashArray", 4)),
              paperBgColor: getVal("paperBgColor", "#ffffff"),
            };
          },

          // 更新纸张物理尺寸及方向
          updateSize: function () {
            const type = document.getElementById("paperSize").value;
            const customDiv = document.getElementById("customSizeInputs");

            // 确定基础宽高
            let w, h;
            if (type === "CUSTOM") {
              customDiv.classList.remove("hidden");
              w = parseInt(document.getElementById("customW").value) || 210;
              h = parseInt(document.getElementById("customH").value) || 297;
            } else {
              customDiv.classList.add("hidden");
              w = CONFIG.SIZES[type].w;
              h = CONFIG.SIZES[type].h;
            }

            // 处理横纵向
            const isLandscape = document.getElementById("paperOrientation").checked;
            const longEdge = Math.max(w, h);
            const shortEdge = Math.min(w, h);

            if (isLandscape) {
              App.state.currentPaper.w = longEdge;
              App.state.currentPaper.h = shortEdge;
            } else {
              App.state.currentPaper.w = shortEdge;
              App.state.currentPaper.h = longEdge;
            }

            // 更新状态与UI
            App.state.baseWidth = App.state.currentPaper.w * CONFIG.MM_TO_PX;
            App.state.baseHeight = App.state.currentPaper.h * CONFIG.MM_TO_PX;

            const orientationLabel = isLandscape ? "横向" : "纵向";
            document.getElementById("canvasSizeLabel").innerText = `${type} - ${orientationLabel} (${App.state.currentPaper.w} x ${App.state.currentPaper.h} mm)`;

            App.zoom.apply(App.state.zoom);
            App.state.hasUnsavedChanges = true;
            this.drawGrid();
          },

          updateSettings: function () {
            const rowCount = document.getElementById("rowCount");
            if (rowCount) document.getElementById("rowCountDisplay").innerText = rowCount.value;
            App.state.hasUnsavedChanges = true;
            this.drawGrid();
          },

          // 绘制网格线
          drawGrid: function () {
            const cfg = this.getSettings();
            const canvas = App.canvas;
            canvas.setBackgroundColor(cfg.paperBgColor, canvas.requestRenderAll.bind(canvas));
            const objects = canvas.getObjects();
            for (let i = objects.length - 1; i >= 0; i--) {
              if (objects[i].isGrid) canvas.remove(objects[i]);
            }

            if (cfg.rowCount === 0) {
              canvas.requestRenderAll();
              return;
            }

            // 计算网格参数
            const width = App.state.baseWidth;
            const height = App.state.baseHeight;
            const contentHeight = height - cfg.marginTop - cfg.marginBottom;
            const lineHeight = contentHeight / cfg.rowCount;
            const startX = cfg.marginLeft;
            const endX = width - cfg.marginRight;

            const gridLines = [];
            // 修改 createLine 函数，支持 options 参数
            const createLine = (x1, y1, x2, y2, strokeW, options = {}) => {
              return new fabric.Line([x1, y1, x2, y2], {
                stroke: cfg.gridColor,
                strokeWidth: strokeW,
                selectable: false,
                evented: false,
                isGrid: true,
                excludeFromExport: true,
                originX: "center",
                originY: "center",
                ...options,
              });
            };

            for (let i = 0; i <= cfg.rowCount; i++) {
              const y = cfg.marginTop + i * lineHeight;

              // 处理首行双线
              if (i === 0 && cfg.doubleFirst) {
                gridLines.push(createLine(startX, y - 2, endX, y - 2, 3));
                gridLines.push(createLine(startX, y + 2, endX, y + 2, 1));
              }
              // 处理尾行双线
              else if (i === cfg.rowCount && cfg.doubleLast) {
                gridLines.push(createLine(startX, y - 2, endX, y - 2, 1));
                gridLines.push(createLine(startX, y + 2, endX, y + 2, 3));
              }
              // 处理中间行
              else {
                let lineOpts = {};

                if (cfg.gridDashed && i > 0 && i < cfg.rowCount) {
                  lineOpts.strokeDashArray = [cfg.gridDashArray, cfg.gridDashArray];
                }
                gridLines.push(createLine(startX, y, endX, y, cfg.strokeWidth, lineOpts));
              }
            }

            gridLines.forEach((line) => {
              canvas.add(line);
              canvas.sendToBack(line);
            });

            canvas.requestRenderAll();
          },

          clearBackground: function () {
            App.canvas.setBackgroundImage(null, () => {
              App.canvas.requestRenderAll();

              const btn = document.getElementById("bgClearBtn");
              if (btn) btn.classList.add("hidden");

              App.ui.updateLayerList();

              App.state.hasUnsavedChanges = true;
              App.history.saveState();
            });
          },
        },

        // --- 缩放与视图管理 ---
        zoom: {
          // 执行缩放 (Point 参数用于以鼠标为中心缩放)
          change: function (delta, point) {
            const oldScale = App.state.zoom;
            let newScale = Math.max(0.1, Math.min(4.0, oldScale + delta));

            if (newScale === oldScale) return;

            this.apply(newScale);

            // 调整滚动条位置以保持视觉中心
            if (point) {
              const container = document.getElementById("scrollContainer");
              const scaleFactor = newScale / oldScale;
              const newScrollLeft = (container.scrollLeft + point.x) * scaleFactor - point.x;
              const newScrollTop = (container.scrollTop + point.y) * scaleFactor - point.y;

              container.scrollLeft = newScrollLeft;
              container.scrollTop = newScrollTop;
            }
          },

          // 自适应屏幕大小
          autoFit: function () {
            const container = document.getElementById("scrollContainer");
            const padding = 60;
            const availW = container.clientWidth - padding;
            const availH = container.clientHeight - padding;

            if (availW <= 0 || availH <= 0) return;

            const scaleW = availW / App.state.baseWidth;
            const scaleH = availH / App.state.baseHeight;

            let scale = Math.min(scaleW, scaleH);
            if (scale > 1.2) scale = 1.2;

            this.apply(scale);

            // 延迟居中滚动
            setTimeout(() => {
              const newW = App.state.baseWidth * scale;
              const newH = App.state.baseHeight * scale;
              container.scrollLeft = (newW - container.clientWidth) / 2 + padding / 2;
              container.scrollTop = (newH - container.clientHeight) / 2 + padding / 2;
            }, 0);
          },

          apply: function (scale) {
            App.state.zoom = scale;
            const w = Math.round(App.state.baseWidth * scale);
            const h = Math.round(App.state.baseHeight * scale);

            App.canvas.setDimensions({ width: w, height: h });
            App.canvas.setZoom(scale);

            const viewport = document.getElementById("zoomViewport");
            if (viewport) {
              viewport.style.width = w + "px";
              viewport.style.height = h + "px";
            }

            document.getElementById("zoomPercent").innerText = Math.round(scale * 100) + "%";
            App.canvas.requestRenderAll();
          },
        },

        // --- 事件管理 ---
        events: {
          initCanvasEvents: function () {
            const container = document.getElementById("scrollContainer");
            let isPanning = false;
            let startX = 0,
              startY = 0,
              scrollLeft = 0,
              scrollTop = 0;
            let dragOrigin = null;
            let isDragThresholdPassed = false;
            const DRAG_THRESHOLD = 3;

            App.canvas.on("mouse:down", function (opt) {
              const target = opt.target;
              if (target && !opt.e.altKey && !target.isGrid) {
                dragOrigin = { left: target.left, top: target.top };
                isDragThresholdPassed = false;
              } else {
                dragOrigin = null;
              }
            });

            // 在对象移动过程中拦截
            App.canvas.on("object:moving", function (opt) {
              const target = opt.target;
              if (dragOrigin && !isDragThresholdPassed) {
                // 计算位移偏差
                const dx = Math.abs(target.left - dragOrigin.left);
                const dy = Math.abs(target.top - dragOrigin.top);

                // 如果移动距离小于阈值，强制锁死在原位
                if (dx < DRAG_THRESHOLD && dy < DRAG_THRESHOLD) {
                  target.set({ left: dragOrigin.left, top: dragOrigin.top });
                  // 阻止后续逻辑（虽然 Fabric 事件不能完全阻止，但通过重置坐标可以视觉上“无效化”）
                  return;
                } else {
                  // 一旦突破阈值，标记为通过，之后不再拦截，允许自由移动
                  isDragThresholdPassed = true;
                }
              }
            });

            App.canvas.on("mouse:up", function () {
              // 鼠标抬起，重置状态
              dragOrigin = null;
              isDragThresholdPassed = false;
            });

            // 画布平移与选框逻辑
            App.canvas.on("mouse:down", function (opt) {
              const evt = opt.e;
              const target = opt.target;

              // 当点击的是空白处或者网格背景时
              if (!target || target.isGrid) {
                // 【修改点】：如果按住了 Alt 键 -> 启用拉框选择
                if (evt.altKey === true) {
                  isPanning = false; // 禁用自定义平移
                  App.canvas.selection = true; // 启用 Fabric 自带的选框功能
                  App.canvas.defaultCursor = "default";
                  App.canvas.setCursor("default");
                }
                // 【修改点】：否则 (没按键) -> 启用拖拽平移画布
                else {
                  isPanning = true; // 标记开始平移
                  App.canvas.selection = false; // 暂时禁用选框，防止拖拽时画出蓝色框

                  // 记录平移起点
                  startX = evt.clientX;
                  startY = evt.clientY;
                  scrollLeft = container.scrollLeft;
                  scrollTop = container.scrollTop;

                  // 改变光标样式
                  App.canvas.defaultCursor = "grabbing";
                  App.canvas.setCursor("grabbing");
                }
              }
            });

            document.addEventListener(
              "mousemove",
              function (e) {
                if (isPanning) {
                  e.preventDefault();
                  container.scrollLeft = scrollLeft - (e.clientX - startX);
                  container.scrollTop = scrollTop - (e.clientY - startY);
                  return;
                }

                if (App.canvas && App.canvas._currentTransform) {
                  e.preventDefault();
                }
              },
              { passive: false }
            );

            document.addEventListener("mouseup", function () {
              if (isPanning) {
                isPanning = false;
                App.canvas.selection = true; // 平移结束后恢复允许选中
                App.canvas.defaultCursor = "default";
                App.canvas.setCursor("default");
              }
            });

            // 2. 滚轮缩放
            container.addEventListener(
              "wheel",
              function (e) {
                e.preventDefault();
                e.stopPropagation();
                const rect = container.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const delta = e.deltaY > 0 ? -0.1 : 0.1;
                App.zoom.change(delta, { x: mouseX, y: mouseY });
              },
              { passive: false }
            );

            // 3. 选中队列维护 (用于多选对齐)
            const updateQueue = (selected, deselected) => {
              if (selected) {
                selected.forEach((obj) => {
                  if (!App.state.selectionQueue.includes(obj)) App.state.selectionQueue.push(obj);
                });
              }
              if (deselected) {
                deselected.forEach((obj) => {
                  const idx = App.state.selectionQueue.indexOf(obj);
                  if (idx > -1) App.state.selectionQueue.splice(idx, 1);
                });
              }
              App.ui.updateInspector();
            };

            App.canvas.on("selection:created", (e) => updateQueue(e.selected, null));
            App.canvas.on("selection:updated", (e) => updateQueue(e.selected, e.deselected));
            App.canvas.on("selection:cleared", () => {
              App.state.selectionQueue = [];
              App.ui.updateInspector();
            });
            container.addEventListener("mousedown", function (e) {
              // 检查点击的目标是否是容器本身，或者是 zoomViewport 的空白处
              // 只有当点击的不是 canvas 元素（upper-canvas）时才取消选中
              if (e.target.id === "scrollContainer" || e.target.id === "zoomViewport" || e.target.id === "canvasWrapper") {
                App.canvas.discardActiveObject(); // 清除 Fabric 选中状态
                App.canvas.requestRenderAll(); // 重绘
                App.ui.updateInspector(); // 更新右侧面板状态
              }
            });
            // 4. 对象修改监听
            App.canvas.on("object:modified", () => App.ui.updateInspector());

            const geoUpdate = (e) => {
              const target = e.target;

              if (["i-text", "textbox", "text"].includes(target.type)) {
                if (Math.abs(target.scaleX - target.scaleY) < 0.01) {
                  if (Math.abs(target.scaleX - 1) > 0.001) {
                    const newFontSize = target.fontSize * target.scaleX;

                    const updates = {
                      fontSize: newFontSize,
                      scaleX: 1,
                      scaleY: 1,
                    };

                    if (target.type === "textbox") {
                      updates.width = target.width * target.scaleX;
                    }

                    target.set(updates);

                    // 4. 更新 UI 显示
                    const propSizeInput = document.getElementById("propSize");
                    if (propSizeInput) {
                      propSizeInput.value = Utils.px2pt(newFontSize);
                    }
                  }
                }
              }

              // 更新几何属性面板 (坐标、宽高、旋转)
              App.ui.updateGeo(null, null, target);
            };

            // 下面这几行保持原样
            App.canvas.on("object:moving", geoUpdate);
            App.canvas.on("object:scaling", geoUpdate);
            App.canvas.on("object:rotating", geoUpdate);
            App.canvas.on("object:resizing", geoUpdate);

            App.canvas.on("object:moving", geoUpdate);
            App.canvas.on("object:scaling", geoUpdate);
            App.canvas.on("object:rotating", geoUpdate);
            App.canvas.on("object:resizing", geoUpdate);

            // 窗口调整事件
            window.addEventListener(
              "resize",
              Utils.throttle(() => App.zoom.autoFit(), 200)
            );
          },
        },

        // 辅助：加载系统字体
        loadLocalFonts: async function () {
          if (!("queryLocalFonts" in window)) {
            return;
          }

          if (App.state.localFontsLoaded) return;

          try {
            App.state.localFontsLoaded = true;

            const fonts = await window.queryLocalFonts();

            const select = document.getElementById("propFont");
            const seen = new Set();
            for (let i = 0; i < select.options.length; i++) {
              seen.add(select.options[i].value);
            }

            const sorted = fonts.sort((a, b) => a.family.localeCompare(b.family));

            if (!seen.has("---sep---")) {
              const sep = document.createElement("option");
              sep.disabled = true;
              sep.text = "--- 本地字体 ---";
              sep.value = "---sep---";
              select.add(sep);
              seen.add("---sep---");
            }

            let count = 0;
            for (const f of sorted) {
              if (!seen.has(f.family)) {
                seen.add(f.family);
                const opt = document.createElement("option");
                opt.value = f.family;
                opt.text = f.fullName;
                opt.style.fontFamily = f.family; // 让下拉框里直接显示字体样式
                select.add(opt);
                count++;
              }
            }

            if (count > 0) Utils.toast(`已加载 ${count} 款本地字体`);
          } catch (e) {
            console.warn("Local font access denied or error", e);
            App.state.localFontsLoaded = false;
          }
        },

        // --- 4. 工具集 (创建与编辑) ---
        tools: {
          _getCenter: function () {
            return {
              left: App.state.baseWidth / 2,
              top: App.state.baseHeight / 2,
            };
          },

          _addToCanvas: function (obj) {
            App.canvas.add(obj);
            App.canvas.setActiveObject(obj);
            App.canvas.requestRenderAll();
            App.ui.updateLayerList();
            App.history.saveState();
          },

          addText: function () {
            const t = new fabric.IText("点击编辑文本", {
              ...this._getCenter(),
              fontSize: Utils.pt2px(14),
              fontFamily: "SimSun",
              fill: App.paper.getSettings().gridColor,
              originX: "center",
              originY: "center",
            });
            this._addToCanvas(t);
          },

          addParagraph: function () {
            const w = App.state.baseWidth - Utils.mm2px(50);
            const t = new fabric.Textbox("在此输入段落文本...\n支持自动换行。", {
              ...this._getCenter(),
              width: w,
              fontSize: Utils.pt2px(12),
              fontFamily: "FangSong",
              fill: "#333333",
              splitByGrapheme: true,
              originX: "center",
              originY: "center",
            });
            this._addToCanvas(t);
          },

          addDate: function () {
            const cfg = App.paper.getSettings();
            const t = new fabric.IText("____年__月__日", {
              left: App.state.baseWidth - cfg.marginRight,
              top: cfg.marginTop - 35,
              fontSize: Utils.pt2px(14),
              fontFamily: "KaiTi",
              fill: cfg.gridColor,
              originX: "right",
            });
            this._addToCanvas(t);
          },

          addPageNum: function () {
            const t = new fabric.IText("第   页", {
              left: App.state.baseWidth / 2,
              top: App.state.baseHeight - Utils.mm2px(20),
              fontSize: Utils.pt2px(12),
              fontFamily: "SimSun",
              fill: App.paper.getSettings().gridColor,
              originX: "center",
              originY: "center",
            });
            this._addToCanvas(t);
          },

          addLine: function () {
            const cfg = App.paper.getSettings();
            const contentWidth = App.state.baseWidth - cfg.marginLeft - cfg.marginRight;
            const l = new fabric.Line([0, 0, contentWidth, 0], {
              ...this._getCenter(),
              stroke: cfg.gridColor,
              strokeWidth: 2,
              originX: "center",
              originY: "center",
            });

            this._addToCanvas(l);
          },

          addShape: function (type) {
            let obj;
            const themeColor = App.paper.getSettings().gridColor;
            const common = {
              ...this._getCenter(),
              fill: themeColor,
              stroke: null,
              strokeWidth: 0,
              originX: "center",
              originY: "center",
            };

            if (type === "rect") obj = new fabric.Rect({ ...common, width: 100, height: 100 });
            else if (type === "circle") obj = new fabric.Circle({ ...common, radius: 50 });
            else if (type === "triangle") obj = new fabric.Triangle({ ...common, width: 100, height: 100 });
            else if (type === "star") {
              const points = [];
              const spikes = 5,
                outerRadius = 50,
                innerRadius = outerRadius * 0.382;
              for (let i = 0; i < spikes * 2; i++) {
                const r = i % 2 === 0 ? outerRadius : innerRadius;
                const angle = (Math.PI * i) / spikes - Math.PI / 2;
                points.push({ x: Math.cos(angle) * r, y: Math.sin(angle) * r });
              }
              obj = new fabric.Polygon(points, { ...common, fill: themeColor, stroke: "transparent" });
            }
            if (obj) this._addToCanvas(obj);
          },

          handleImageUpload: function (input) {
            if (input.files && input.files[0]) {
              const reader = new FileReader();
              reader.onload = (e) => {
                fabric.Image.fromURL(e.target.result, (img) => {
                  img.scaleToWidth(Utils.mm2px(50));
                  img.set({ ...this._getCenter(), originX: "center", originY: "center", stroke: null, strokeWidth: 0 });
                  this._addToCanvas(img);
                  input.value = "";
                });
              };
              reader.readAsDataURL(input.files[0]);
            }
          },
          replaceActiveImage: function (input) {
            const active = App.canvas.getActiveObject();
            if (!active || active.type !== "image" || !input.files || !input.files[0]) return;

            const reader = new FileReader();
            reader.onload = (e) => {
              const imgObj = new Image();
              imgObj.src = e.target.result;
              imgObj.onload = function () {
                // 设置新的图片源
                active.setSrc(e.target.result, () => {
                  App.canvas.renderAll();
                  App.ui.updateLayerList();
                  App.history.saveState();
                  Utils.toast("图片已替换");
                });
              };
            };
            reader.readAsDataURL(input.files[0]);
            input.value = ""; // 重置 input 防止重复选择不触发
          },

          setAsBackground: function () {
            const active = App.canvas.getActiveObject();

            if (active && active.type === "image") {
              const bgOptions = {
                originX: active.originX,
                originY: active.originY,
                left: active.left,
                top: active.top,
                scaleX: active.scaleX,
                scaleY: active.scaleY,
                angle: active.angle,
                opacity: active.opacity,
              };

              App.canvas.setBackgroundImage(
                active,
                () => {
                  App.canvas.remove(active);
                  App.canvas.requestRenderAll();

                  const btn = document.getElementById("bgClearBtn");
                  if (btn) btn.classList.remove("hidden");

                  App.ui.updateLayerList();

                  App.state.hasUnsavedChanges = true;
                  App.history.saveState();
                  Utils.toast("已设为背景");
                },
                bgOptions
              );
            } else {
              Utils.toast("请先选中一张图片", "error");
            }
          },

          deleteActive: function () {
            const active = App.canvas.getActiveObject();
            if (!active) return;

            if (active.type === "activeSelection") {
              active.forEachObject((o) => App.canvas.remove(o));
              App.canvas.discardActiveObject();
            } else {
              App.canvas.remove(active);
            }
            App.ui.updateLayerList();
            App.ui.updateInspector();
            App.history.saveState();
          },

          // 键盘微调移动
          nudge: function (dir) {
            const active = App.canvas.getActiveObject();
            if (!active) return;
            const step = 2; // 每次移动像素数
            if (dir === "up") active.top -= step;
            if (dir === "down") active.top += step;
            if (dir === "left") active.left -= step;
            if (dir === "right") active.left += step;
            active.setCoords();
            App.canvas.requestRenderAll();
            App.ui.updateGeo(null, null, active);
          },
          updateSmartCorner: function (key, value) {
            const active = App.canvas.getActiveObject();
            if (!active) return;

            if (active.type !== "rect" && !active.isSmartRect) return;

            let config = active.cornerConfig || { tl: 0, tr: 0, bl: 0, br: 0, style: "round" };

            value = key === "style" ? value : parseInt(value) || 0;

            if (key === "all") {
              config.tl = config.tr = config.bl = config.br = value;
              ["tl", "tr", "bl", "br"].forEach((k) => {
                const el = document.getElementById("corner" + k.toUpperCase());
                if (el) el.value = value;
              });
              document.getElementById("masterRadiusVal").innerText = value;
            } else if (key === "style") {
              config.style = value;
            } else {
              config[key] = value;
            }

            const w = active.getScaledWidth();
            const h = active.getScaledHeight();

            const pathData = Utils.generateSmartRectPath(w, h, config, config.style);

            const newObj = new fabric.Path(pathData, {
              left: active.left,
              top: active.top,
              fill: active.fill,
              stroke: active.stroke,
              strokeWidth: active.strokeWidth,
              opacity: active.opacity,
              angle: active.angle,
              scaleX: 1,
              scaleY: 1,
              originX: active.originX,
              originY: active.originY,
              isSmartRect: true,
              cornerConfig: config,
              transparentCorners: false,
              cornerColor: "white",
              cornerStrokeColor: "#3b82f6",
              borderColor: "#3b82f6",
              borderScaleFactor: 1.5,
            });

            // 保持层级位置
            const index = App.canvas.getObjects().indexOf(active);

            App.canvas.discardActiveObject();
            App.canvas.remove(active);
            App.canvas.insertAt(newObj, index, true); // true 表示不重新渲染，稍后统一渲染
            App.canvas.setActiveObject(newObj);
            App.canvas.requestRenderAll();
            App.ui.updateInspector();
            App.history.saveState();
          },
          flip: function (dir) {
            const active = App.canvas.getActiveObject();
            if (!active) return;

            if (active.type === "activeSelection") {
              const group = active.toGroup();
              if (dir === "x") group.set("flipX", !group.flipX);
              else if (dir === "y") group.set("flipY", !group.flipY);
              const newSelection = group.toActiveSelection();
              App.canvas.setActiveObject(newSelection);
            } else {
              if (dir === "x") active.set("flipX", !active.flipX);
              else if (dir === "y") active.set("flipY", !active.flipY);
            }

            App.canvas.requestRenderAll();

            App.ui.updateInspector();

            App.history.saveState();
          },
        },

        // --- 5. UI 管理 (属性面板与图层) ---
        ui: {
          // 更新几何属性
          updateGeo: function (key, val, targetObj = null) {
            const active = targetObj || App.canvas.getActiveObject();
            if (!active) return;

            // A. 读取属性到 Input (Canvas像素 -> UI毫米)
            if (val === undefined || val === null) {
              const p = active.getPointByOrigin("left", "top"); // 获取左上角绝对坐标(px)

              // 转换: px -> mm，并保留1位小数
              document.getElementById("propX").value = Utils.px2mm(p.x).toFixed(1);
              document.getElementById("propY").value = Utils.px2mm(p.y).toFixed(1);

              // 角度不需要转换
              document.getElementById("propAngle").value = Math.round(active.angle);

              // 转换: px -> mm，保留1位小数
              document.getElementById("propW").value = Utils.px2mm(active.getScaledWidth()).toFixed(1);
              document.getElementById("propH").value = Utils.px2mm(active.getScaledHeight()).toFixed(1);
              return;
            }

            // B. 从 Input 更新属性 (UI毫米 -> Canvas像素)
            const numVal = parseFloat(val);
            if (isNaN(numVal)) return;

            if (key === "angle") {
              // 角度直接设置
              active.set("angle", numVal);
            } else {
              // 距离/尺寸需要转换: mm -> px
              const pxVal = Utils.mm2px(numVal);

              if (key === "left" || key === "top") {
                // 获取当前UI上的毫米值，转为像素
                let currentLeftMm = parseFloat(document.getElementById("propX").value);
                let currentTopMm = parseFloat(document.getElementById("propY").value);

                // 如果当前修改的是 left，用新的输入值；否则用旧值
                let finalLeftPx = key === "left" ? pxVal : Utils.mm2px(currentLeftMm);
                let finalTopPx = key === "top" ? pxVal : Utils.mm2px(currentTopMm);

                // 移动对象
                active.setPositionByOrigin(new fabric.Point(finalLeftPx, finalTopPx), "left", "top");
              } else if (key === "width") {
                // 宽度处理
                if (active.type === "textbox") {
                  active.set("width", pxVal);
                } else {
                  // 对于普通形状/图片，通过 scaleX 改变宽度
                  // scaleX = 目标像素宽 / 原始像素宽
                  active.set("scaleX", pxVal / active.width);
                }
              } else if (key === "height") {
                // 高度处理
                // scaleY = 目标像素高 / 原始像素高
                active.set("scaleY", pxVal / active.height);
              }
            }

            active.setCoords();
            App.canvas.requestRenderAll();
            App.history.saveState();
          },

          // 设置对象属性 (支持多选)
          setProp: function (key, val) {
            const active = App.canvas.getActiveObject();
            if (active) {
              if (active.type === "activeSelection") {
                active.forEachObject((o) => o.set(key, val));
              } else {
                active.set(key, val);
              }
              App.canvas.requestRenderAll();
              App.history.saveState();
            }
          },
          updateLineDash: function () {
            const active = App.canvas.getActiveObject();
            if (!active || active.type !== "line") return;

            const isDashed = document.getElementById("lineDashCheck").checked;
            const val = parseInt(document.getElementById("lineDashVal").value) || 5;

            if (isDashed) {
              // 设置虚线数组 [实线长度, 间隔长度]
              active.set("strokeDashArray", [val, val]);
            } else {
              active.set("strokeDashArray", null);
            }

            App.canvas.requestRenderAll();
            App.history.saveState();
          },
          toggleStyle: function (style) {
            const active = App.canvas.getActiveObject();
            if (!active) return;
            if (style === "bold") active.set("fontWeight", active.fontWeight === "bold" ? "normal" : "bold");
            else if (style === "italic") active.set("fontStyle", active.fontStyle === "italic" ? "normal" : "italic");
            else if (style === "underline") active.set("underline", !active.underline);
            App.canvas.requestRenderAll();
            this.updateInspector();
            App.history.saveState();
          },

          // 更新右侧属性面板显隐
          updateInspector: function () {
            const active = App.canvas.getActiveObject();
            const els = {
              none: document.getElementById("noSelection"),
              controls: document.getElementById("selectionControls"),
              text: document.getElementById("textProps"),
              img: document.getElementById("imgProps"),
              line: document.getElementById("lineProps"),
              shape: document.getElementById("shapeProps"),
              align: document.getElementById("alignTools"),
              fineTune: document.getElementById("fineTuneTools"),
            };

            // 重置
            els.none.classList.remove("hidden");
            els.controls.classList.add("hidden");
            [els.text, els.img, els.line, els.shape, els.align].forEach((e) => e.classList.add("hidden"));

            if (!active) {
              this.updateLayerList();
              return;
            }

            els.none.classList.add("hidden");
            els.controls.classList.remove("hidden");

            // 更新通用数据
            this.updateGeo(null, null, active);
            document.getElementById("propOpacity").value = active.opacity || 1;
            document.getElementById("opacityVal").innerText = Math.round((active.opacity || 1) * 100) + "%";

            // 根据类型显示面板
            if (active.type === "activeSelection") {
              els.align.classList.remove("hidden");
              els.fineTune.classList.remove("hidden");
            } else {
              els.fineTune.classList.remove("hidden");

              if (["i-text", "textbox", "text"].includes(active.type)) {
                els.text.classList.remove("hidden");
                document.getElementById("propFont").value = active.fontFamily;
                document.getElementById("propSize").value = Utils.px2pt(active.fontSize);
                document.getElementById("propColor").value = active.fill;
                document.getElementById("propLineHeight").value = active.lineHeight || 1.2;
                document.getElementById("propCharSpacing").value = active.charSpacing || 0;
                document.getElementById("btnBold").classList.toggle("active", active.fontWeight === "bold");
                document.getElementById("btnItalic").classList.toggle("active", active.fontStyle === "italic");
                document.getElementById("btnUnderline").classList.toggle("active", !!active.underline);
              } else if (active.type === "image") {
                els.img.classList.remove("hidden");
              } else if (active.type === "line") {
                els.line.classList.remove("hidden");
                document.getElementById("lineColor").value = active.stroke;
                document.getElementById("lineStrokeWidth").value = active.strokeWidth;

                const dashArray = active.strokeDashArray;
                const isDashed = dashArray && dashArray.length > 0;
                document.getElementById("lineDashCheck").checked = isDashed;
                document.getElementById("lineDashVal").value = isDashed ? dashArray[0] : 5;
              } else if (["rect", "circle", "triangle", "polygon", "path"].includes(active.type)) {
                els.shape.classList.remove("hidden");
                document.getElementById("shapeFill").value = active.fill === "transparent" ? "#ffffff" : active.fill;
                document.getElementById("shapeStroke").value = active.stroke || "#000000";
                document.getElementById("shapeStrokeWidth").value = active.strokeWidth || 0;

                const cornerControl = document.getElementById("rectCornerControl");

                // 判断：是普通矩形 或者是 我们转换过的 SmartRect
                if (active.type === "rect" || active.isSmartRect) {
                  cornerControl.classList.remove("hidden");

                  // 获取配置，如果没有则从 rx 读取 (兼容普通 Rect)
                  const conf = active.cornerConfig || {
                    tl: active.rx || 0,
                    tr: active.rx || 0,
                    bl: active.rx || 0,
                    br: active.rx || 0,
                    style: "round",
                  };

                  // 填充 UI
                  document.getElementById("cornerStyle").value = conf.style;
                  document.getElementById("cornerTL").value = conf.tl;
                  document.getElementById("cornerTR").value = conf.tr;
                  document.getElementById("cornerBL").value = conf.bl;
                  document.getElementById("cornerBR").value = conf.br;

                  // 如果四个角相等，更新滑块，否则滑块归零或显示特定状态
                  if (conf.tl === conf.tr && conf.tr === conf.bl && conf.bl === conf.br) {
                    document.getElementById("masterRadius").value = conf.tl;
                    document.getElementById("masterRadiusVal").innerText = conf.tl;
                  }
                } else {
                  cornerControl.classList.add("hidden");
                }
              }
            }
            this.updateLayerList();
          },
          showLoading: function (msg = "加载中...") {
            const el = document.getElementById("loadingOverlay");
            if (el) {
              el.querySelector("p").innerText = msg;
              el.classList.remove("hidden");
            }
          },

          hideLoading: function () {
            const el = document.getElementById("loadingOverlay");
            if (el) el.classList.add("hidden");
          },
          // 绝对对齐 (相对于画布)
          alignObject: function (mode) {
            const active = App.canvas.getActiveObject();
            if (!active) return;

            const cfg = App.paper.getSettings();
            const contentW = App.state.baseWidth - cfg.marginLeft - cfg.marginRight;
            const centerX = cfg.marginLeft + contentW / 2;

            if (mode === "centerH") active.set({ left: centerX, originX: "center" });
            else if (mode === "left") active.set({ left: cfg.marginLeft, originX: "left" });
            else if (mode === "right") active.set({ left: App.state.baseWidth - cfg.marginRight, originX: "right" });

            active.setCoords();
            App.canvas.requestRenderAll();
            this.updateGeo(null, null, active);
            App.history.saveState();
          },

          // 多选对齐 (以首个选中对象为基准)
          align: function (mode) {
            if (App.state.selectionQueue.length < 2) return;

            const queue = [...App.state.selectionQueue];
            const anchor = queue[0]; // 基准对象

            // 暂时解散组以计算绝对坐标
            App.canvas.discardActiveObject();
            queue.forEach((obj) => obj.setCoords());

            const anchorRect = anchor.getBoundingRect(true);

            queue.forEach((obj) => {
              if (obj === anchor) return;
              const objRect = obj.getBoundingRect(true);
              let dx = 0,
                dy = 0;

              switch (mode) {
                case "left":
                  dx = anchorRect.left - objRect.left;
                  break;
                case "center":
                  dx = anchorRect.left + anchorRect.width / 2 - (objRect.left + objRect.width / 2);
                  break;
                case "right":
                  dx = anchorRect.left + anchorRect.width - (objRect.left + objRect.width);
                  break;
                case "top":
                  dy = anchorRect.top - objRect.top;
                  break;
                case "middle":
                  dy = anchorRect.top + anchorRect.height / 2 - (objRect.top + objRect.height / 2);
                  break;
                case "bottom":
                  dy = anchorRect.top + anchorRect.height - (objRect.top + objRect.height);
                  break;
              }

              if (dx !== 0) obj.set("left", obj.left + dx);
              if (dy !== 0) obj.set("top", obj.top + dy);
              obj.setCoords();
            });

            // 恢复选中组
            const newSelection = new fabric.ActiveSelection(queue, { canvas: App.canvas });
            App.canvas.setActiveObject(newSelection);
            App.canvas.requestRenderAll();
            App.history.saveState();
          },
          // 平均分布 (按对象中心点分布)
          distribute: function (mode) {
            const active = App.canvas.getActiveObject();
            if (!active || active.type !== "activeSelection") {
              Utils.toast("请至少选择3个元素", "info");
              return;
            }

            const objs = active.getObjects();
            if (objs.length < 3) {
              Utils.toast("分布至少需要3个元素", "info");
              return;
            }

            App.canvas.discardActiveObject();

            if (mode === "horizontal") {
              objs.sort((a, b) => a.left - b.left);

              const first = objs[0];
              const last = objs[objs.length - 1];

              const minCenter = first.getCenterPoint().x;
              const maxCenter = last.getCenterPoint().x;
              const totalDistance = maxCenter - minCenter;
              const step = totalDistance / (objs.length - 1);

              // 重新计算中间元素的位置
              objs.forEach((obj, index) => {
                if (index === 0 || index === objs.length - 1) return; // 首尾不动

                const targetCenterX = minCenter + step * index;
                const currentCenter = obj.getCenterPoint();
                // 计算位移增量
                const deltaX = targetCenterX - currentCenter.x;

                obj.set("left", obj.left + deltaX);
                obj.setCoords();
              });
            } else if (mode === "vertical") {
              // 按 top 从小到大排序
              objs.sort((a, b) => a.top - b.top);

              const first = objs[0];
              const last = objs[objs.length - 1];

              const minCenter = first.getCenterPoint().y;
              const maxCenter = last.getCenterPoint().y;
              const totalDistance = maxCenter - minCenter;
              const step = totalDistance / (objs.length - 1);

              objs.forEach((obj, index) => {
                if (index === 0 || index === objs.length - 1) return;

                const targetCenterY = minCenter + step * index;
                const currentCenter = obj.getCenterPoint();
                const deltaY = targetCenterY - currentCenter.y;

                obj.set("top", obj.top + deltaY);
                obj.setCoords();
              });
            }

            // 3. 重新建立选中区
            const newSelection = new fabric.ActiveSelection(objs, { canvas: App.canvas });
            App.canvas.setActiveObject(newSelection);

            App.canvas.requestRenderAll();
            // 4. 强制刷新面板 (防止因解组导致的面板闪烁隐藏)
            App.ui.updateInspector();
            App.history.saveState();
          },

          // 图层列表管理
          // 在 App.ui 对象内替换 updateLayerList 方法
          updateLayerList: function () {
            const list = document.getElementById("layerList");
            list.innerHTML = "";

            // 1. 获取普通对象 (反转数组，让最上面的图层显示在列表顶部)
            const objs = App.canvas
              .getObjects()
              .filter((o) => !o.isGrid)
              .reverse();
            const activeObjs = App.canvas.getActiveObjects();

            // 2. 获取背景图片
            const bgImg = App.canvas.backgroundImage;

            if (objs.length === 0 && !bgImg) {
              list.innerHTML = '<div class="text-gray-400 text-center py-4">暂无图层</div>';
              return;
            }

            // --- 辅助函数：创建图层行 ---
            const createLayerRow = (iconClass, nameText, isActive, isBackground, onClick, onDelete) => {
              const div = document.createElement("div");
              // 给背景图层加一点特殊的背景色(bg-gray-50)以示区别
              const bgClass = isBackground ? "bg-gray-50/80 italic text-slate-500" : "hover:bg-gray-50";

              div.className = `layer-item flex items-center justify-between px-2 py-2 border-b border-gray-100 last:border-0 cursor-pointer transition ${isActive ? "active" : bgClass}`;

              // 左侧内容
              div.innerHTML = `
      <div class="flex items-center gap-2 w-full overflow-hidden">
        <i class="ph ${iconClass} ${isActive ? "text-blue-500" : "text-gray-400"}"></i>
        <span class="truncate select-none text-xs ${isActive ? "font-bold" : ""}">${nameText}</span>
      </div>
    `;

              // 右侧删除按钮
              const delBtn = document.createElement("button");
              delBtn.className = "p-1 text-gray-400 hover:text-red-600 hover:bg-red-50 rounded transition shrink-0 ml-2";
              delBtn.title = "删除图层";
              delBtn.innerHTML = `<i class="ph ph-trash"></i>`;

              delBtn.onclick = (e) => {
                e.stopPropagation(); // 阻止触发选中
                onDelete();
              };

              div.onclick = onClick;
              div.appendChild(delBtn);

              return div;
            };

            // --- A. 渲染普通对象 ---
            objs.forEach((o) => {
              let icon = "ph-square";
              if (o.type.includes("text")) icon = "ph-text-t";
              else if (o.type === "image") icon = "ph-image";
              else if (["rect", "circle", "triangle", "polygon", "path"].includes(o.type)) icon = "ph-shapes";
              else if (o.type === "line") icon = "ph-line-segment";

              const name = o.text ? o.text.substring(0, 10) : o.type === "image" ? "图片" : o.type;
              const isActive = activeObjs.includes(o);

              const row = createLayerRow(
                icon,
                name,
                isActive,
                false,
                (e) => {
                  // 点击选中逻辑
                  if (e.ctrlKey) {
                    const newSel = isActive ? activeObjs.filter((i) => i !== o) : [...activeObjs, o];
                    const sel = new fabric.ActiveSelection(newSel, { canvas: App.canvas });
                    App.canvas.setActiveObject(sel);
                  } else {
                    App.canvas.setActiveObject(o);
                  }
                  App.canvas.requestRenderAll();
                },
                () => {
                  // 删除逻辑
                  App.canvas.remove(o);
                  App.canvas.discardActiveObject();
                  App.ui.updateLayerList();
                  App.ui.updateInspector();
                  App.history.saveState();
                }
              );
              list.appendChild(row);
            });

            // --- B. 渲染背景图片 (固定在列表最底部) ---
            if (bgImg) {
              const bgRow = createLayerRow(
                "ph-image-square", // 图标
                "【背景】图片", // 名称带前缀
                false, // 背景图不可被常规选中
                true, // 标记为背景类型
                () => {
                  // 点击背景行不做选中操作
                  // 可选：Utils.toast("背景图已锁定，请使用右侧按钮删除");
                },
                () => {
                  // 删除背景逻辑
                  if (confirm("确定要移除背景图片吗？")) {
                    App.paper.clearBackground();
                  }
                }
              );
              list.appendChild(bgRow);
            }
          },

          moveLayer: function (dir) {
            const active = App.canvas.getActiveObject();
            if (!active) return;
            if (dir === "up") active.bringForward();
            else active.sendBackwards();

            // 保持网格在最底层
            App.canvas.getObjects().forEach((o) => {
              if (o.isGrid) App.canvas.sendToBack(o);
            });

            App.canvas.requestRenderAll();
            this.updateLayerList();
            App.history.saveState();
          },

          toggleFullScreen: function () {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else if (document.exitFullscreen) document.exitFullscreen();
          },

          showModal: function (id) {
            document.getElementById(id).classList.remove("hidden");
          },
          hideModal: function (id) {
            document.getElementById(id).classList.add("hidden");
          },
        },

        // --- 6. IO 系统 (存取、导入导出) ---
        io: {
          _getHighResDataURL: function () {
            const originalVpt = App.canvas.viewportTransform.slice();
            const originalWidth = App.canvas.width;
            const originalHeight = App.canvas.height;
            const originalActive = App.canvas.getActiveObject();

            const originalBg = App.canvas.backgroundColor;

            const currentBgColor = App.paper.getSettings().paperBgColor;

            App.canvas.discardActiveObject();

            App.canvas.getObjects().forEach((obj) => {
              if (obj.type === "image" && !obj.isGrid) {
                obj.set({ stroke: null, strokeWidth: 0 });
              }
            });

            App.canvas.setBackgroundColor(currentBgColor, () => {});

            App.canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
            App.canvas.setDimensions({
              width: App.state.baseWidth,
              height: App.state.baseHeight,
            });

            App.canvas.renderAll();

            // 导出图片
            const dataUrl = App.canvas.toDataURL({
              format: "jpeg",
              quality: 0.9,
              multiplier: 3,
            });

            App.canvas.setViewportTransform(originalVpt);
            App.canvas.setDimensions({
              width: originalWidth,
              height: originalHeight,
            });

            App.canvas.setBackgroundColor(originalBg, () => {});

            if (originalActive) {
              App.canvas.setActiveObject(originalActive);
            }
            App.canvas.requestRenderAll();

            return dataUrl;
          },

          saveProject: function () {
            const thumb = App.canvas.toDataURL({ format: "png", multiplier: 0.7, quality: 0.8 });

            const json = App.canvas.toJSON(["id", "isGrid", "selectable", "evented"]);
            json.objects = json.objects.filter((o) => !o.isGrid);
            const project = {
              version: "4.0",
              timestamp: new Date().toISOString(),
              settings: App.paper.getSettings(),
              paperSize: document.getElementById("paperSize").value,
              thumbnail: thumb,
              canvasData: json,
            };

            const blob = new Blob([JSON.stringify(project)], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `信笺纸_${new Date().getTime()}.paper`;
            a.click();
            URL.revokeObjectURL(url);
            Utils.toast("项目已保存");
            App.state.hasUnsavedChanges = false;
          },
          //加载项目数据的核心逻辑
          loadProjectData: function (data) {
            try {
              // 1. 解析基础设置
              const s = data.settings;
              if (s) {
                const setVal = (id, v) => {
                  if (document.getElementById(id)) document.getElementById(id).value = v;
                };
                const setChk = (id, v) => {
                  if (document.getElementById(id)) document.getElementById(id).checked = v;
                };

                setVal("marginTop", Math.round(Utils.px2mm(s.marginTop)));
                setVal("marginBottom", Math.round(Utils.px2mm(s.marginBottom)));
                setVal("marginLeft", Math.round(Utils.px2mm(s.marginLeft)));
                setVal("marginRight", Math.round(Utils.px2mm(s.marginRight)));
                setVal("rowCount", s.rowCount);
                setVal("gridColor", s.gridColor);
                setVal("strokeWidth", s.strokeWidth);
                setVal("paperBgColor", s.paperBgColor || "#ffffff");
                setChk("doubleFirst", s.doubleFirst);
                setChk("doubleLast", s.doubleLast);
                setChk("gridDashed", s.gridDashed);
                setVal("gridDashArray", s.gridDashArray);

                if (data.paperSize) setVal("paperSize", data.paperSize);
              }

              // 2. 应用尺寸并清空画布
              App.paper.updateSize();
              App.canvas.clear();

              const onLoaded = () => {
                App.paper.drawGrid(); // 重绘网格
                App.ui.hideModal("welcomeModal"); // 关闭选择模态框
                App.ui.updateLayerList(); // 更新图层列表
                App.history.reset(); // 重置历史记录
                App.state.hasUnsavedChanges = false;
                App.ui.hideLoading();
                const btn = document.getElementById("bgClearBtn");
                if (App.canvas.backgroundImage) {
                  btn.classList.remove("hidden");
                } else {
                  btn.classList.add("hidden");
                }
              };

              if (data.canvasData) {
                App.canvas.loadFromJSON(data.canvasData, onLoaded);
              } else {
                onLoaded();
              }
            } catch (err) {
              console.error(err);
              Utils.toast("数据解析异常", "error");
              App.ui.hideLoading(); // 发生错误时也要关闭
            }
          },
          loadProject: function (file) {
            if (!file) return;
            App.ui.showLoading("正在打开文件..."); // 显示 loading

            const reader = new FileReader();
            reader.onload = (e) => {
              try {
                const data = JSON.parse(e.target.result);
                this.loadProjectData(data); // 调用核心逻辑
              } catch (err) {
                Utils.toast("文件格式错误", "error");
              } finally {
                App.ui.hideLoading(); // 关闭 loading
              }
            };
            reader.readAsText(file);
          },
          exportPDF: function () {
            const imgData = this._getHighResDataURL();

            const w = App.state.currentPaper.w;
            const h = App.state.currentPaper.h;
            const orientation = w > h ? "l" : "p";

            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF({
              orientation: orientation,
              unit: "mm",
              format: [w, h],
            });

            pdf.addImage(imgData, "PNG", 0, 0, w, h);
            pdf.save(`信笺纸导出_${new Date().getTime()}.pdf`);
            Utils.toast("PDF 导出成功");
          },

          print: function () {
            const dataUrl = this._getHighResDataURL();
            const iframeId = "print-iframe-sandbox";
            let iframe = document.getElementById(iframeId);
            if (iframe) document.body.removeChild(iframe);

            iframe = document.createElement("iframe");
            iframe.id = iframeId;
            iframe.style.cssText = "position:fixed; top:0; left:0; width:1px; height:1px; opacity:0; pointer-events:none;";
            document.body.appendChild(iframe);

            const doc = iframe.contentWindow.document;
            const w = App.state.currentPaper.w;
            const h = App.state.currentPaper.h;

            // 关键修改：将结束标签打断，防止 live-server 注入
            const content =
              `
              <!DOCTYPE html>
              <html>
                <head>
                  <style>
                    body { display: flex; justify-content: center; align-items: flex-start; margin: 0; padding: 0;}
                    img { width: 100%; height: auto; object-fit: contain; display: block;border:none; -webkit-optimize-contrast; }
                    @page {
                      size: ${w}mm ${h}mm; 
                      margin: 0; 
                    }
                    @media print {
                      html, body, #printContainer {
                        margin: 0 !important;
                        padding: 0 !important;
                        overflow: hidden !important; 
                        width: 100%; height: 100%;
                      }
                      #printContainer {
                        display: block !important;
                        position: absolute; top: 0; left: 0; z-index: 99999;
                      }
                    }
                  </style>
                </head>
                <body>
                  <img src="${dataUrl}" onload="setTimeout(() => { window.print(); }, 200);">
                ` +
              "<" +
              "/body>" +
              `
              ` +
              "<" +
              "/html>";

            doc.open();
            doc.write(content);
            doc.close();
          },

          copy: function () {
            const active = App.canvas.getActiveObject();
            if (!active) return;
            active.clone((cloned) => {
              App.state.clipboard = cloned;
              App.state.pasteCount = 0;
            });
          },

          paste: function () {
            if (!App.state.clipboard) return;
            App.state.pasteCount++;
            const offset = 20 * App.state.pasteCount;

            App.state.clipboard.clone((cloned) => {
              App.canvas.discardActiveObject();
              cloned.set({ left: cloned.left + offset, top: cloned.top + offset, evented: true });

              if (cloned.type === "activeSelection") {
                cloned.canvas = App.canvas;
                cloned.forEachObject((o) => App.canvas.add(o));
                cloned.setCoords();
              } else {
                App.canvas.add(cloned);
              }

              App.canvas.setActiveObject(cloned);
              App.canvas.requestRenderAll();
              App.ui.updateLayerList();
              App.history.saveState();
            });
          },
        },

        // --- 7. 模板系统 ---
        templates: {
          data: [],

          init: async function () {
            try {
              // 这里的路径请根据实际情况调整，如果使用了服务器，确保 fetch 能获取到
              const response = await fetch("./static/templates.json");
              this.data = await response.json();
              this.renderGrid();
            } catch (error) {
              console.error("Templates load failed:", error);
              Utils.toast("模板列表加载失败", "error");
            }
          },

          renderGrid: function () {
            const grid = document.getElementById("templateGrid");
            if (!grid) return;
            grid.innerHTML = "";

            this.data.forEach((t) => {
              const div = document.createElement("div");
              div.className = "template-card bg-white p-3 rounded-xl border border-gray-200 cursor-pointer transition flex flex-col gap-2";

              // 兼容 thumbnail 为空的情况
              const visualContent = t.thumbnail ? `<img src="${t.thumbnail}" class="h-full w-auto object-contain mx-auto" alt="${t.name}">` : `<i class="ph ph-file-plus text-3xl text-gray-300"></i>`;

              div.innerHTML = `
        <div class="h-36 bg-gray-50 rounded-lg overflow-hidden flex items-center justify-center border border-gray-100">
            ${visualContent}
        </div>
        <div>
            <h3 class="font-bold text-slate-700 text-sm">${t.name}</h3>
            <p class="text-slate-400 line-clamp-1 text-xs">${t.desc || "点击创建"}</p>
        </div>`;

              div.onclick = () => this.load(t.id);
              grid.appendChild(div);
            });
          },

          // [核心修改] 加载逻辑
          load: async function (id) {
            const t = this.data.find((i) => i.id === id);
            if (!t) return;

            // 情况 1: 存在 URL，远程获取 .paper 文件
            if (t.url) {
              App.ui.showLoading("正在下载模板...");

              try {
                const res = await fetch(t.url);
                if (!res.ok) throw new Error("Network response was not ok");

                const projectData = await res.json();

                // 使用 App.io 中重构好的逻辑加载数据
                App.io.loadProjectData(projectData);
              } catch (error) {
                console.error(error);
                Utils.toast("模板文件加载失败", "error");
                App.ui.hideLoading();
              }
            }
            // 情况 2: 没有 URL，执行默认 A4 空白逻辑
            else {
              this.loadBlankA4();
            }
          },

          // 默认空白 A4 逻辑 (从原代码逻辑提取并简化)
          loadBlankA4: function () {
            App.ui.showLoading("正在创建...");

            // 模拟稍微的延迟，让 UI 转换更平滑
            setTimeout(() => {
              // 1. 重置 UI 控件到默认值
              const defaults = {
                paperSize: "A4",
                marginTop: 35,
                marginBottom: 35,
                marginLeft: 28,
                marginRight: 28,
                rowCount: 0,
                gridColor: "#e11d48",
                strokeWidth: 1,
              };

              document.getElementById("paperSize").value = defaults.paperSize;
              document.getElementById("marginTop").value = defaults.marginTop;
              document.getElementById("marginBottom").value = defaults.marginBottom;
              document.getElementById("marginLeft").value = defaults.marginLeft;
              document.getElementById("marginRight").value = defaults.marginRight;
              document.getElementById("rowCount").value = defaults.rowCount;
              document.getElementById("gridColor").value = defaults.gridColor;
              document.getElementById("strokeWidth").value = defaults.strokeWidth;

              // 复选框默认值
              document.getElementById("doubleFirst").checked = true;
              document.getElementById("doubleLast").checked = true;
              document.getElementById("gridDashed").checked = false;

              // 2. 应用纸张尺寸
              App.paper.updateSize();

              // 3. 清空画布
              App.canvas.clear();
              App.paper.drawGrid(); // 重绘网格

              // 4. 重置状态
              App.ui.hideModal("welcomeModal");
              App.ui.updateLayerList();
              App.history.reset();
              App.ui.hideLoading();
            }, 200);
          },
        },
      };

      // --- 8. 初始化与事件绑定 ---

      function initHotkeys() {
        const isInputActive = () => {
          const el = document.activeElement;
          return el && (el.tagName === "INPUT" || el.tagName === "TEXTAREA" || el.contentEditable === "true");
        };

        // 1. 撤销/重做 (保留原逻辑，但增加输入框检测)
        hotkeys("ctrl+z,command+z", (e) => {
          if (isInputActive()) return;
          e.preventDefault();
          App.history.undo();
        });

        hotkeys("ctrl+y,command+y", (e) => {
          if (isInputActive()) return;
          e.preventDefault();
          App.history.redo();
        });

        // 2. 保存/打开 (通常全局有效，但为了保险也可以加检测)
        hotkeys("ctrl+s,command+s", (e) => {
          e.preventDefault();
          App.io.saveProject();
        });

        hotkeys("ctrl+o,command+o", (e) => {
          e.preventDefault();
          document.getElementById("projectImportInput").click();
        });

        hotkeys("ctrl+c,command+c", (e) => {
          if (isInputActive()) return;
          const selection = window.getSelection();
          if (selection && selection.toString().length > 0) {
            return;
          }
          const active = App.canvas.getActiveObject();
          if (active) {
            e.preventDefault();
            App.io.copy();
          }
        });

        hotkeys("ctrl+v,command+v", (e) => {
          if (isInputActive()) return;
          if (App.state.clipboard) {
            e.preventDefault();
            App.io.paste();
          }
        });

        // 4. 粘贴
        hotkeys("ctrl+v,command+v", (e) => {
          if (isInputActive()) return; // 在输入框里按 Ctrl+V，执行默认粘贴文字

          if (App.state.clipboard) {
            e.preventDefault();
            App.io.paste();
          }
        });

        hotkeys("ctrl+p,command+p", (e) => {
          e.preventDefault();
          App.io.print();
        });

        // 删除键
        hotkeys("del,backspace", (e) => {
          if (isInputActive()) return;
          e.preventDefault();
          App.tools.deleteActive();
        });

        // 方向键微调
        hotkeys("up,down,left,right", (e, handler) => {
          if (isInputActive()) return;
          if (App.canvas.getActiveObject()) {
            e.preventDefault();
            App.tools.nudge(handler.key);
          }
        });
      }

      document.getElementById("imgUpload").onchange = function (e) {
        App.tools.handleImageUpload(this);
      };
      document.getElementById("projectImportInput").onchange = function (e) {
        App.io.loadProject(this.files[0]);
      };

      document.getElementById("welcomeModal").addEventListener("click", (e) => {
        if (e.target.id === "welcomeModal") App.ui.hideModal("welcomeModal");
      });

      document.getElementById("imgReplaceInput").onchange = function (e) {
        App.tools.replaceActiveImage(this);
      };

      document.addEventListener("fullscreenchange", () => {
        const icon = document.getElementById("fsIcon");
        icon.classList.toggle("ph-corners-out", !document.fullscreenElement);
        icon.classList.toggle("ph-corners-in", !!document.fullscreenElement);
        setTimeout(() => App.zoom.autoFit(), 100);
      });

      window.onload = function () {
        App.init();
        App.templates.init();
        initHotkeys();
        window.onbeforeunload = function () {
          if (App.state.hasUnsavedChanges) {
            return "您的更改可能未保存，确定要离开吗？";
          }
        };
      };
    </script>
  </body>
</html>
